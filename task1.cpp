#include <iostream>
#include <iomanip>
using namespace std;
// #include <functional>
// #include <algorithm>
#include <vector>
// #include <string>
// #include <cmath>
// #include <cstdlib>
// #include<utility>
// #include <exception>
// #include <bitset>

void info(const vector<int>& v){ //вывод информации о размере и ёмкости
  cout<<"##############\n"<<"size="<<v.size()<<endl<<"capacity="<<v.capacity()<<endl<<"##############\n"<<endl;
}


void overflow(vector<int>& v){ //вызов переполнения памяти с фиксацией
                                //абсолютного и относительного измерения capacity
  cout<<"flag"<<endl;
  unsigned long long int i=0;
  double capacity=v.capacity();
  // vector<int> v;
  while (true){

    v.push_back(i);
    i++;
    if (capacity!=v.capacity()){
      cout<<"ratio="<<v.capacity()/capacity<<endl;
      capacity=v.capacity();
      cout<<"cap="<<capacity<<endl<<endl<<endl;
    }
  }
}


int main(){
  system("chcp 1251");
  cout<<endl;
  vector<int> v;
  info(v);
  v={1,2,3,4,5,6,7,8,9,10};
  info (v); // изначально размер совпадает с ёмкостью и равен 0
  v.push_back(100);
  info(v); // размер совпадает с ёмкостью и равен 100
  for (size_t i = 0; i < 100; i++) {
    v.push_back(i);
    cout<<"i="<<i<<endl;
    info(v);
  } // из этого цикла видно, что как только для добавления нового элемента не хватает
    //ёмкости, то ёмкость ветора увеличивается ровно в 2 раза по сравнению с предыдущим значением


    //часть2
  cout<<"________________________"<<endl;
  vector<int> v2;
  v2.reserve(10);
  info (v2); // размер 0, ёмкость задана вручную -10
  v2.reserve(100);
  info(v2); // размер также 0, ёмкость расширена до 100
  v2.reserve(10);
  info(v2); // размер 0. Ёмкость не уменьшилась, хотя было выполнено изменение ёмкости
           //Т.е моно сделать вывод, что
            //единожды зарезервированное место вектор освобождать не будет, даже
            //если в нем уже нет потребности.

  //часть 3
  vector<int> v3;
  v3.reserve(13);
  // overflow(v3);
  //раскомментировав строчку выше сможем наблюдать в бесконечном цикле выделение
  //все большего и большего кол-ва памяти под вектор из-за заполнения его числами. Можно
  //проследить, что увеличение ёмкости всегда происходит ровно в 2 раза и если
  //очередное расширение в два раза провести не удается, то выбрасывается исключение
  //bad_alloc. Попытка запросить меньшее количество памяти для расширения менее чем в 2 раза
  // не предпринимается

  v3.reserve(4.50104e+008); // опытным путем подобрано около критическое значение
                            //ёмкости. Расширение в 2 раза из этого состояния уже невозможно.

  for (size_t i = 0; i < static_cast<int>(4.50104e+008) ; i++) {
    v3.push_back(1); // заполняем всю выделенную ёмкость какими-то значениями
  }
  info(v3);// емкость равна размеру -> добалвение еще одного объекта должно вызвать
          //расширение ёмкости вектора.
  v3.push_back(1);// выбрасывается bad_alloc, несмотря на то что выделить места
                  //на 1 элемент больше- возможно. Но расширение также происходит
                  //только в 2 раза, а вот найти такой объем памияти не уается.

//Итог: Можно делать вывод, что на моей машине реализация управления памяти вектором
//довольно примитивная. При нехватку ёмкости для добавления новго элеметна происходит
//расширение ровно в 2 раза. Если расширить в 2 раза не удается- выбрасывается исключение
//даже не смотря на то что найти новое место с чуть меньшим запасом может быть возможно





}
