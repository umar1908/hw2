1)Когда нужно сгрупировать несколько разных типов данных вместе .
В случае пары-два типа данных, кортежа- несколько. Обычно используются на данных,
которые неразрывно связаны друг с другом (например ключ-значение, (x,y))
2)Замена классическому статичному массиву C (дополненный множеством полезных функиий).
Один из самых быстрых контейнеров.Использовать следует только в случаях когда заранее
известен его размер.
3)Вектор- замена динамическому массиву. Стоит всегда использовать вместо классического
подхода с ручным выделением памяти из кучи и использования указателей т.к в векторе
реализовано множество полезных функиий в том числе удовлетворяется аксиома RAII,
есть проверка выхода за границы массива
4)очередь хорошо поойдет для последовательной обработки поступающих запросов(например
обработка сервером запросов, поступающих от клиентов) Правда в таком случае можно
огнаничиться односторонней очереью
5)Двусторонний список следует использовать для работы с большими объемами
динамически выделяемой памяти (когда выделение последовательного куска необходимого
размера становится невозможным)
6) Аналогично двухстороннему списку. Если не обязательно иметь возможность возвращаться
назад, то можно уменьшить размер занимаемый элементом списка использовав
односторонний список
7) Стек, очередь, приоритетная очередь
8)Позволяетм организовать возможность буфферизации потоков данных без испоьзования
динамического выделения памяти.
9) Потому что требование стандарта- конечный итератор всегда должен быть больше начального,
что в кольце невозможно.
10) классические многомерные массивы, вложенные векторы, просто последовательно
выделенная память+логика работы с указателями на ней, boost::multy_array
